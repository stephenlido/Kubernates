# ðŸ§­ From YAML to Running Pod in Kubernetes

This document explains how a simple YAML manifest becomes a running Pod in Kubernetes, visualizing the internal components involved.

---

## Example YAML

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:latest
        ports:
        - containerPort: 80
```

---

## ðŸ”¹ Step 1 â€” You Apply the YAML

```bash
kubectl apply -f nginx-deployment.yaml
```

`kubectl`:

* Reads your YAML file.
* Converts it to JSON (since Kubernetes API speaks JSON).
* Authenticates using your kubeconfig.
* Sends a REST call to the API server:

  ```
  POST /apis/apps/v1/namespaces/default/deployments
  ```

---

## âš™ï¸ Step 2 â€” API Server (The Heart)

The **kube-apiserver** receives the JSON request.

It:

* Validates fields (`apiVersion`, `kind`, `spec`, etc.).
* Checks your RBAC permissions.
* Stores the object in **etcd** â€” Kubernetes' key-value database.

ðŸ“¦ etcd now contains your **desired state** for this Deployment.

---

## ðŸ” Step 3 â€” Controllers Start Working

The **Deployment Controller** (part of the `kube-controller-manager`) sees a new Deployment and:

* Creates a **ReplicaSet**.
* That ReplicaSet creates **3 Pods** with matching labels.

All these objects are stored in etcd as well.

---

## âš™ï¸ Step 4 â€” Scheduler Assigns Pods

The **kube-scheduler** watches for unscheduled Pods and assigns them to nodes based on:

* CPU/memory availability.
* Node selectors or taints/tolerations.

Once assigned, it updates each Pod spec with the chosen `nodeName`.

---

## ðŸ§± Step 5 â€” Kubelet Pulls the Image & Starts Containers

On the assigned node:

* **kubelet** detects the new Pod.
* It instructs the **container runtime** (containerd/Docker) to:

  * Pull the specified image (`nginx:latest`).
  * Start the container.
  * Expose the declared ports.

At this point, your Pod is running.

---

## ðŸ” Step 6 â€” Continuous Reconciliation

Kubernetes continuously compares:

* **Desired State** (in etcd)
* **Actual State** (reported by kubelets)

If a Pod crashes or node fails, controllers automatically recreate or move Pods until the desired and actual states match again.

---

## ðŸ“Š Architecture Flow Diagram (Text Representation)

```
Your YAML
   â”‚
   â–¼
kubectl apply
   â”‚ (REST JSON)
   â–¼
kube-apiserver
   â”‚
   â–¼
etcd  â†â”€â”€ (stores desired state)
   â”‚
   â–¼
Controller Manager (creates ReplicaSets, Pods)
   â”‚
   â–¼
Scheduler (assigns Pods to Nodes)
   â”‚
   â–¼
Kubelet on Node
   â”‚
   â–¼
Container Runtime (runs containers)
```

---

## ðŸ’¬ Recap

| Step | Component               | What It Does                              |
| ---- | ----------------------- | ----------------------------------------- |
| 1    | **kubectl**             | Sends YAML to the API server              |
| 2    | **API Server**          | Validates and stores config in etcd       |
| 3    | **Controller Manager**  | Creates ReplicaSets and Pods              |
| 4    | **Scheduler**           | Assigns Pods to nodes                     |
| 5    | **Kubelet**             | Runs containers on the node               |
| 6    | **Reconciliation Loop** | Keeps actual state matching desired state |

---

## âœ… Summary

Every YAML manifest in Kubernetes is a **declaration of desired state**. The control plane components work together in a feedback loop to ensure that the actual cluster state always matches that desired declaration.

> Kubernetes = Declarative + Self-Healing + Automated
